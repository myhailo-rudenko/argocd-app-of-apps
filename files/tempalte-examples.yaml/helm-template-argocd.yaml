---
# Source: root-chart/templates/argocd-apps/cert-manager/cert-manager.yaml
apiVersion: v1
kind: Namespace
metadata:
  name: cert-manager
---
# Source: root-chart/templates/argocd-apps/gitea.yaml
apiVersion: v1
kind: Namespace
metadata:
  name: gitea
---
# Source: root-chart/templates/argocd-apps/kube-prometheus-stack.yaml
apiVersion: v1
kind: Namespace
metadata:
  name: monitoring
---
# Source: root-chart/templates/argocd-apps/root.yaml
apiVersion: v1
kind: Namespace
metadata:
  name: argo-cd
---
# Source: root-chart/charts/argo-cd/charts/redis/templates/serviceaccount.yaml
apiVersion: v1
kind: ServiceAccount
automountServiceAccountToken: true
metadata:
  name: release-name-redis
  namespace: "argo-cd"
  labels:
    app.kubernetes.io/name: redis
    helm.sh/chart: redis-17.0.2
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/managed-by: Helm
---
# Source: root-chart/charts/argo-cd/templates/application-controller/service-account.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: release-name-argo-cd-argocd-app-controller
  namespace: "argo-cd"
  labels:
    app.kubernetes.io/name: argo-cd
    helm.sh/chart: argo-cd-4.0.2
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/component: controller
automountServiceAccountToken: true
---
# Source: root-chart/charts/argo-cd/templates/repo-server/service-account.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: release-name-argo-cd-argocd-repo-server
  namespace: "argo-cd"
  labels:
    app.kubernetes.io/name: argo-cd
    helm.sh/chart: argo-cd-4.0.2
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/component: repo-server
automountServiceAccountToken: true
---
# Source: root-chart/charts/argo-cd/templates/server/service-account.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: release-name-argo-cd-argocd-server
  namespace: "argo-cd"
  labels:
    app.kubernetes.io/name: argo-cd
    helm.sh/chart: argo-cd-4.0.2
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/component: server
automountServiceAccountToken: true
---
# Source: root-chart/charts/argo-cd/charts/redis/templates/secret.yaml
apiVersion: v1
kind: Secret
metadata:
  name: release-name-redis
  namespace: "argo-cd"
  labels:
    app.kubernetes.io/name: redis
    helm.sh/chart: redis-17.0.2
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/managed-by: Helm
type: Opaque
data:
  redis-password: "YkYyN0ZsV0U4cQ=="
---
# Source: root-chart/charts/argo-cd/templates/argocd-secret.yaml
apiVersion: v1
kind: Secret
metadata:
  # Mandatory hardcoded name.
  # Ref: https://github.com/argoproj/argo-cd/blob/master/docs/operator-manual/argocd-secret.yaml
  name: argocd-secret
  namespace: "argo-cd"
  labels:
    app.kubernetes.io/name: argo-cd
    helm.sh/chart: argo-cd-4.0.2
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/managed-by: Helm
    # Mandatory label
    # Ref: https://argoproj.github.io/argo-cd/operator-manual/declarative-setup/#atomic-configuration
    app.kubernetes.io/part-of: argocd
type: Opaque
data:
  clearPassword: "cFNYdXlEcERRNQ=="
  # The password needs to be bcrypt hashed
  admin.password: JDJhJDEwJFVnLlJOU1VmaFVISFhlM2RYU0lZdXVLb2Rya0RUZXhtOGl5NDdMRFNlcFVoV00wbkxMUmZT
  admin.passwordMtime: MjAyMi0wNy0yOVQwOTo1NjoyNFo=
---
# Source: root-chart/charts/argo-cd/charts/redis/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: release-name-redis-configuration
  namespace: "argo-cd"
  labels:
    app.kubernetes.io/name: redis
    helm.sh/chart: redis-17.0.2
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/managed-by: Helm
data:
  redis.conf: |-
    # User-supplied common configuration:
    # Enable AOF https://redis.io/topics/persistence#append-only-file
    appendonly yes
    # Disable RDB persistence, AOF persistence already enabled.
    save ""
    # End of common configuration
  master.conf: |-
    dir /data
    # User-supplied master configuration:
    rename-command FLUSHDB ""
    rename-command FLUSHALL ""
    # End of master configuration
  replica.conf: |-
    dir /data
    # User-supplied replica configuration:
    rename-command FLUSHDB ""
    rename-command FLUSHALL ""
    # End of replica configuration
---
# Source: root-chart/charts/argo-cd/charts/redis/templates/health-configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: release-name-redis-health
  namespace: "argo-cd"
  labels:
    app.kubernetes.io/name: redis
    helm.sh/chart: redis-17.0.2
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/managed-by: Helm
data:
  ping_readiness_local.sh: |-
    #!/bin/bash

    [[ -f $REDIS_PASSWORD_FILE ]] && export REDIS_PASSWORD="$(< "${REDIS_PASSWORD_FILE}")"
    [[ -n "$REDIS_PASSWORD" ]] && export REDISCLI_AUTH="$REDIS_PASSWORD"
    response=$(
      timeout -s 3 $1 \
      redis-cli \
        -h localhost \
        -p $REDIS_PORT \
        ping
    )
    if [ "$?" -eq "124" ]; then
      echo "Timed out"
      exit 1
    fi
    if [ "$response" != "PONG" ]; then
      echo "$response"
      exit 1
    fi
  ping_liveness_local.sh: |-
    #!/bin/bash

    [[ -f $REDIS_PASSWORD_FILE ]] && export REDIS_PASSWORD="$(< "${REDIS_PASSWORD_FILE}")"
    [[ -n "$REDIS_PASSWORD" ]] && export REDISCLI_AUTH="$REDIS_PASSWORD"
    response=$(
      timeout -s 3 $1 \
      redis-cli \
        -h localhost \
        -p $REDIS_PORT \
        ping
    )
    if [ "$?" -eq "124" ]; then
      echo "Timed out"
      exit 1
    fi
    responseFirstWord=$(echo $response | head -n1 | awk '{print $1;}')
    if [ "$response" != "PONG" ] && [ "$responseFirstWord" != "LOADING" ] && [ "$responseFirstWord" != "MASTERDOWN" ]; then
      echo "$response"
      exit 1
    fi
  ping_readiness_master.sh: |-
    #!/bin/bash

    [[ -f $REDIS_MASTER_PASSWORD_FILE ]] && export REDIS_MASTER_PASSWORD="$(< "${REDIS_MASTER_PASSWORD_FILE}")"
    [[ -n "$REDIS_MASTER_PASSWORD" ]] && export REDISCLI_AUTH="$REDIS_MASTER_PASSWORD"
    response=$(
      timeout -s 3 $1 \
      redis-cli \
        -h $REDIS_MASTER_HOST \
        -p $REDIS_MASTER_PORT_NUMBER \
        ping
    )
    if [ "$?" -eq "124" ]; then
      echo "Timed out"
      exit 1
    fi
    if [ "$response" != "PONG" ]; then
      echo "$response"
      exit 1
    fi
  ping_liveness_master.sh: |-
    #!/bin/bash

    [[ -f $REDIS_MASTER_PASSWORD_FILE ]] && export REDIS_MASTER_PASSWORD="$(< "${REDIS_MASTER_PASSWORD_FILE}")"
    [[ -n "$REDIS_MASTER_PASSWORD" ]] && export REDISCLI_AUTH="$REDIS_MASTER_PASSWORD"
    response=$(
      timeout -s 3 $1 \
      redis-cli \
        -h $REDIS_MASTER_HOST \
        -p $REDIS_MASTER_PORT_NUMBER \
        ping
    )
    if [ "$?" -eq "124" ]; then
      echo "Timed out"
      exit 1
    fi
    responseFirstWord=$(echo $response | head -n1 | awk '{print $1;}')
    if [ "$response" != "PONG" ] && [ "$responseFirstWord" != "LOADING" ]; then
      echo "$response"
      exit 1
    fi
  ping_readiness_local_and_master.sh: |-
    script_dir="$(dirname "$0")"
    exit_status=0
    "$script_dir/ping_readiness_local.sh" $1 || exit_status=$?
    "$script_dir/ping_readiness_master.sh" $1 || exit_status=$?
    exit $exit_status
  ping_liveness_local_and_master.sh: |-
    script_dir="$(dirname "$0")"
    exit_status=0
    "$script_dir/ping_liveness_local.sh" $1 || exit_status=$?
    "$script_dir/ping_liveness_master.sh" $1 || exit_status=$?
    exit $exit_status
---
# Source: root-chart/charts/argo-cd/charts/redis/templates/scripts-configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: release-name-redis-scripts
  namespace: "argo-cd"
  labels:
    app.kubernetes.io/name: redis
    helm.sh/chart: redis-17.0.2
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/managed-by: Helm
data:
  start-master.sh: |
    #!/bin/bash

    [[ -f $REDIS_PASSWORD_FILE ]] && export REDIS_PASSWORD="$(< "${REDIS_PASSWORD_FILE}")"
    if [[ ! -f /opt/bitnami/redis/etc/master.conf ]];then
        cp /opt/bitnami/redis/mounted-etc/master.conf /opt/bitnami/redis/etc/master.conf
    fi
    if [[ ! -f /opt/bitnami/redis/etc/redis.conf ]];then
        cp /opt/bitnami/redis/mounted-etc/redis.conf /opt/bitnami/redis/etc/redis.conf
    fi
    ARGS=("--port" "${REDIS_PORT}")
    ARGS+=("--requirepass" "${REDIS_PASSWORD}")
    ARGS+=("--masterauth" "${REDIS_PASSWORD}")
    ARGS+=("--include" "/opt/bitnami/redis/etc/redis.conf")
    ARGS+=("--include" "/opt/bitnami/redis/etc/master.conf")
    exec redis-server "${ARGS[@]}"
---
# Source: root-chart/charts/argo-cd/templates/argocd-cm.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  # Mandatory hardcoded name.
  # Ref: https://github.com/argoproj/argo-cd/blob/master/docs/operator-manual/argocd-cm.yaml
  name: argocd-cm
  namespace: "argo-cd"
  labels:
    app.kubernetes.io/name: argo-cd
    helm.sh/chart: argo-cd-4.0.2
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/managed-by: Helm
    # Mandatory label
    # Ref: https://argoproj.github.io/argo-cd/operator-manual/declarative-setup/#atomic-configuration
    app.kubernetes.io/part-of: argocd
data:
  application.instanceLabelKey: argocd.argoproj.io/instance
  dex.config: ""
  url: ''
---
# Source: root-chart/charts/argo-cd/templates/known-hosts-cm.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  # Mandatory hardcoded name.
  # Ref: https://argoproj.github.io/argo-cd/operator-manual/declarative-setup/#ssh-known-host-public-keys
  name: argocd-ssh-known-hosts-cm
  namespace: "argo-cd"
  labels:
    app.kubernetes.io/name: argo-cd
    helm.sh/chart: argo-cd-4.0.2
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/managed-by: Helm
    # Mandatory label
    # Ref: https://argoproj.github.io/argo-cd/operator-manual/declarative-setup/#atomic-configuration
    app.kubernetes.io/part-of: argocd
data:
  ssh_known_hosts: |
    bitbucket.org ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAubiN81eDcafrgMeLzaFPsw2kNvEcqTKl/VqLat/MaB33pZy0y3rJZtnqwR2qOOvbwKZYKiEO1O6VqNEBxKvJJelCq0dTXWT5pbO2gDXC6h6QDXCaHo6pOHGPUy+YBaGQRGuSusMEASYiWunYN0vCAI8QaXnWMXNMdFP3jHAJH0eDsoiGnLPBlBp4TNm6rYI74nMzgz3B9IikW4WVK+dc8KZJZWYjAuORU3jc1c/NPskD2ASinf8v3xnfXeukU0sJ5N6m5E8VLjObPEO+mN2t/FZTMZLiFqPWc/ALSqnMnnhwrNi2rbfg/rd/IpL8Le3pSBne8+seeFVBoGqzHM9yXw==
    github.com ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAq2A7hRGmdnm9tUDbO9IDSwBK6TbQa+PXYPCPy6rbTrTtw7PHkccKrpp0yVhp5HdEIcKr6pLlVDBfOLX9QUsyCOV0wzfjIJNlGEYsdlLJizHhbn2mUjvSAHQqZETYP81eFzLQNnPHt4EVVUh7VfDESU84KezmD5QlWpXLmvU31/yMf+Se8xhHTvKSCZIFImWwoG6mbUoWf9nzpIoaSjB+weqqUUmpaaasXVal72J+UX2B+2RPW3RcT0eOzQgqlJL3RKrTJvdsjE3JEAvGq3lGHSZXy28G3skua2SmVi/w4yCE6gbODqnTWlg7+wC604ydGXA8VJiS5ap43JXiUFFAaQ==
    gitlab.com ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBFSMqzJeV9rUzU4kWitGjeR4PWSa29SPqJ1fVkhtj3Hw9xjLVXVYrU9QlYWrOLXBpQ6KWjbjTDTdDkoohFzgbEY=
    gitlab.com ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIAfuCHKVTjquxvt6CM6tdG4SLp1Btn/nOeHHE5UOzRdf
    gitlab.com ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCsj2bNKTBSpIYDEGk9KxsGh3mySTRgMtXL583qmBpzeQ+jqCMRgBqB98u3z++J1sKlXHWfM9dyhSevkMwSbhoR8XIq/U0tCNyokEi/ueaBMCvbcTHhO7FcwzY92WK4Yt0aGROY5qX2UKSeOvuP4D6TPqKF1onrSzH9bx9XUf2lEdWT/ia1NEKjunUqu1xOB/StKDHMoX4/OKyIzuS0q/T1zOATthvasJFoPrAjkohTyaDUz2LN5JoH839hViyEG82yB+MjcFV5MU3N1l1QL3cVUCh93xSaua1N85qivl+siMkPGbO5xR/En4iEY6K2XPASUEMaieWVNTRCtJ4S8H+9
    ssh.dev.azure.com ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC7Hr1oTWqNqOlzGJOfGJ4NakVyIzf1rXYd4d7wo6jBlkLvCA4odBlL0mDUyZ0/QUfTTqeu+tm22gOsv+VrVTMk6vwRU75gY/y9ut5Mb3bR5BV58dKXyq9A9UeB5Cakehn5Zgm6x1mKoVyf+FFn26iYqXJRgzIZZcZ5V6hrE0Qg39kZm4az48o0AUbf6Sp4SLdvnuMa2sVNwHBboS7EJkm57XQPVU3/QpyNLHbWDdzwtrlS+ez30S3AdYhLKEOxAG8weOnyrtLJAUen9mTkol8oII1edf7mWWbWVf0nBmly21+nZcmCTISQBtdcyPaEno7fFQMDD26/s0lfKob4Kw8H
    vs-ssh.visualstudio.com ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC7Hr1oTWqNqOlzGJOfGJ4NakVyIzf1rXYd4d7wo6jBlkLvCA4odBlL0mDUyZ0/QUfTTqeu+tm22gOsv+VrVTMk6vwRU75gY/y9ut5Mb3bR5BV58dKXyq9A9UeB5Cakehn5Zgm6x1mKoVyf+FFn26iYqXJRgzIZZcZ5V6hrE0Qg39kZm4az48o0AUbf6Sp4SLdvnuMa2sVNwHBboS7EJkm57XQPVU3/QpyNLHbWDdzwtrlS+ez30S3AdYhLKEOxAG8weOnyrtLJAUen9mTkol8oII1edf7mWWbWVf0nBmly21+nZcmCTISQBtdcyPaEno7fFQMDD26/s0lfKob4Kw8H
---
# Source: root-chart/charts/argo-cd/templates/application-controller/clusterrole.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: release-name-argo-cd-app-controller
  namespace: "argo-cd"
  labels:
    app.kubernetes.io/name: argo-cd
    helm.sh/chart: argo-cd-4.0.2
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/managed-by: Helm
rules:
  - apiGroups:
      - '*'
    resources:
      - '*'
    verbs:
      - '*'
  - nonResourceURLs:
      - '*'
    verbs:
      - '*'
---
# Source: root-chart/charts/argo-cd/templates/server/clusterrole.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: release-name-argo-cd-server
  namespace: "argo-cd"
  labels:
    app.kubernetes.io/name: argo-cd
    helm.sh/chart: argo-cd-4.0.2
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/managed-by: Helm
rules:
  - apiGroups:
      - '*'
    resources:
      - '*'
    verbs:
      - delete
      - get
      - patch
  - apiGroups:
      - ""
    resources:
      - events
    verbs:
      - list
  - apiGroups:
      - ""
    resources:
      - pods
      - pods/log
    verbs:
      - get
---
# Source: root-chart/charts/argo-cd/templates/application-controller/clusterrolebinding.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: release-name-argo-cd-app-controller
  namespace: "argo-cd"
  labels:
    app.kubernetes.io/name: argo-cd
    helm.sh/chart: argo-cd-4.0.2
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/managed-by: Helm
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: release-name-argo-cd-app-controller
subjects:
  - kind: ServiceAccount
    name: release-name-argo-cd-argocd-app-controller
    namespace: argo-cd
---
# Source: root-chart/charts/argo-cd/templates/server/clusterrolebinding.yaml
kind: ClusterRoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: release-name-argo-cd-server
  namespace: "argo-cd"
  labels:
    app.kubernetes.io/name: argo-cd
    helm.sh/chart: argo-cd-4.0.2
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/component: server
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: release-name-argo-cd-server
subjects:
  - kind: ServiceAccount
    name: release-name-argo-cd-argocd-server
    namespace: argo-cd
---
# Source: root-chart/charts/argo-cd/templates/application-controller/role.yaml
kind: Role
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: release-name-argo-cd-app-controller
  namespace: "argo-cd"
  labels:
    app.kubernetes.io/name: argo-cd
    helm.sh/chart: argo-cd-4.0.2
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/managed-by: Helm
rules:
  - apiGroups:
      - ""
    resources:
      - secrets
      - configmaps
    verbs:
      - get
      - list
      - watch
  - apiGroups:
      - argoproj.io
    resources:
      - applications
      - appprojects
    verbs:
      - create
      - get
      - list
      - watch
      - update
      - patch
      - delete
  - apiGroups:
      - ""
    resources:
      - events
    verbs:
      - create
      - list
---
# Source: root-chart/charts/argo-cd/templates/repo-server/role.yaml
kind: Role
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: release-name-argo-cd-repo-server
  namespace: "argo-cd"
  labels:
    app.kubernetes.io/name: argo-cd
    helm.sh/chart: argo-cd-4.0.2
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/managed-by: Helm
rules:
  - apiGroups:
      - argoproj.io
    resources:
      - applications
    verbs:
      - get
      - list
      - watch
---
# Source: root-chart/charts/argo-cd/templates/server/role.yaml
kind: Role
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: release-name-argo-cd-server
  namespace: "argo-cd"
  labels:
    app.kubernetes.io/name: argo-cd
    helm.sh/chart: argo-cd-4.0.2
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/managed-by: Helm
rules:
  - apiGroups:
      - ""
    resources:
      - secrets
      - configmaps
    verbs:
      - create
      - get
      - list
      - watch
      - update
      - patch
      - delete
  - apiGroups:
      - argoproj.io
    resources:
      - applications
      - appprojects
    verbs:
      - create
      - get
      - list
      - watch
      - update
      - delete
      - patch
  - apiGroups:
      - ""
    resources:
      - events
    verbs:
      - create
      - list
---
# Source: root-chart/charts/argo-cd/templates/application-controller/rolebinding.yaml
kind: RoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: release-name-argo-cd-app-controller
  namespace: "argo-cd"
  labels:
    app.kubernetes.io/name: argo-cd
    helm.sh/chart: argo-cd-4.0.2
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/managed-by: Helm
subjects:
  - kind: ServiceAccount
    name: release-name-argo-cd-argocd-app-controller
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: release-name-argo-cd-app-controller
---
# Source: root-chart/charts/argo-cd/templates/repo-server/rolebinding.yaml
kind: RoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: release-name-argo-cd-repo-server
  namespace: "argo-cd"
  labels:
    app.kubernetes.io/name: argo-cd
    helm.sh/chart: argo-cd-4.0.2
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/managed-by: Helm
subjects:
  - kind: ServiceAccount
    name: release-name-argo-cd-argocd-repo-server
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: release-name-argo-cd-repo-server
---
# Source: root-chart/charts/argo-cd/templates/server/rolebinding.yaml
kind: RoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: release-name-argo-cd-server
  namespace: "argo-cd"
  labels:
    app.kubernetes.io/name: argo-cd
    helm.sh/chart: argo-cd-4.0.2
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/managed-by: Helm
subjects:
  - kind: ServiceAccount
    name: release-name-argo-cd-argocd-server
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: release-name-argo-cd-server
---
# Source: root-chart/charts/argo-cd/charts/redis/templates/headless-svc.yaml
apiVersion: v1
kind: Service
metadata:
  name: release-name-redis-headless
  namespace: "argo-cd"
  labels:
    app.kubernetes.io/name: redis
    helm.sh/chart: redis-17.0.2
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/managed-by: Helm
  annotations:

spec:
  type: ClusterIP
  clusterIP: None
  ports:
    - name: tcp-redis
      port: 6379
      targetPort: redis
  selector:
    app.kubernetes.io/name: redis
    app.kubernetes.io/instance: release-name
---
# Source: root-chart/charts/argo-cd/charts/redis/templates/master/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: release-name-redis-master
  namespace: "argo-cd"
  labels:
    app.kubernetes.io/name: redis
    helm.sh/chart: redis-17.0.2
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/component: master
spec:
  type: ClusterIP
  internalTrafficPolicy: Cluster
  sessionAffinity: None
  ports:
    - name: tcp-redis
      port: 6379
      targetPort: redis
      nodePort: null
  selector:
    app.kubernetes.io/name: redis
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/component: master
---
# Source: root-chart/charts/argo-cd/templates/application-controller/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: release-name-argo-cd-app-controller
  namespace: "argo-cd"
  labels:
    app.kubernetes.io/name: argo-cd
    helm.sh/chart: argo-cd-4.0.2
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/component: controller
spec:
  type: ClusterIP
  sessionAffinity: None
  ports:
    - name: tcp-controller
      port: 8082
      targetPort: controller
      protocol: TCP
      nodePort: null
  selector:
    app.kubernetes.io/name: argo-cd
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/component: controller
---
# Source: root-chart/charts/argo-cd/templates/repo-server/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: release-name-argo-cd-repo-server
  namespace: "argo-cd"
  labels:
    app.kubernetes.io/name: argo-cd
    helm.sh/chart: argo-cd-4.0.2
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/component: repo-server
spec:
  type: ClusterIP
  sessionAffinity: None
  ports:
    - name: tcp-repo-server
      port: 8081
      targetPort: repo-server
      protocol: TCP
      nodePort: null
  selector:
    app.kubernetes.io/name: argo-cd
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/component: repo-server
---
# Source: root-chart/charts/argo-cd/templates/server/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: release-name-argo-cd-server
  namespace: "argo-cd"
  labels:
    app.kubernetes.io/name: argo-cd
    helm.sh/chart: argo-cd-4.0.2
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/component: server
spec:
  type: ClusterIP
  sessionAffinity: None
  ports:
    - name: http
      port: 80
      targetPort: http
      protocol: TCP
      nodePort: null
    - name: https
      port: 443
      # NOTE: Argo CD uses only one port (8080) configured with https and always redirects http request to it, so the target port is the same than for http
      targetPort: http
      protocol: TCP
      nodePort: null
  selector:
    app.kubernetes.io/name: argo-cd
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/component: server
---
# Source: root-chart/charts/argo-cd/templates/application-controller/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: release-name-argo-cd-app-controller
  namespace: "argo-cd"
  labels:
    app.kubernetes.io/name: argo-cd
    helm.sh/chart: argo-cd-4.0.2
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/component: controller
spec:
  replicas: 1
  strategy:
    type: RollingUpdate
  selector:
    matchLabels:
      app.kubernetes.io/name: argo-cd
      app.kubernetes.io/instance: release-name
      app.kubernetes.io/component: controller
  template:
    metadata:
      labels:
        app.kubernetes.io/name: argo-cd
        helm.sh/chart: argo-cd-4.0.2
        app.kubernetes.io/instance: release-name
        app.kubernetes.io/managed-by: Helm
        app.kubernetes.io/component: controller
    spec:
      serviceAccountName: release-name-argo-cd-argocd-app-controller

      affinity:
        podAffinity:

        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
            - podAffinityTerm:
                labelSelector:
                  matchLabels:
                    app.kubernetes.io/name: argo-cd
                    app.kubernetes.io/instance: release-name
                    app.kubernetes.io/component: controller
                namespaces:
                  - "argo-cd"
                topologyKey: kubernetes.io/hostname
              weight: 1
        nodeAffinity:

      securityContext:
        fsGroup: 1001
      initContainers:
        - name: wait-for-redis
          image: docker.io/bitnami/redis:7.0.4-debian-11-r2
          imagePullPolicy: "IfNotPresent"
          command:
            - /bin/bash
          args:
            - -ec
            - |
                #!/bin/bash

                set -o errexit
                set -o nounset
                set -o pipefail

                . /opt/bitnami/scripts/libos.sh
                . /opt/bitnami/scripts/liblog.sh

                check_redis_connection() {
                  local result="$(redis-cli -h release-name-redis-master -p 6379 PING)"
                  if [[ "$result" != "PONG" ]]; then
                    false
                  fi
                }

                info "Checking redis connection..."
                if ! retry_while "check_redis_connection"; then
                    error "Could not connect to the Redis server"
                    return 1
                else
                    info "Connected to the Redis instance"
                fi
          env:
            - name: REDISCLI_AUTH
              valueFrom:
                secretKeyRef:
                  name: release-name-redis
                  key: redis-password
      containers:
        - name: controller
          image: docker.io/bitnami/argo-cd:2.4.7-debian-11-r0
          imagePullPolicy: IfNotPresent
          securityContext:
            allowPrivilegeEscalation: false
            capabilities:
              drop:
              - all
            readOnlyRootFilesystem: false
            runAsNonRoot: true
            runAsUser: 1001
          args:
            - argocd-application-controller
            - --status-processors
            - "20"
            - --operation-processors
            - "10"
            - --app-resync
            - "180"
            - --self-heal-timeout-seconds
            - "5"
            - --repo-server
            - release-name-argo-cd-repo-server:8081
            - --logformat
            - text
            - --loglevel
            - info
            # TODO(miguelaeh): Test the chart using redis sentinel enabled: https://github.com/argoproj/argo-cd/blob/2a410187565e15633b6f2a8c8d8da22cf02b257d/util/cache/cache.go#L40
            - --redis
            - release-name-redis-master:6379
          ports:
            - name: controller
              containerPort: 8082
              protocol: TCP
            - name: metrics
              containerPort: 8082
              protocol: TCP
          env:
            - name: REDIS_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: release-name-redis
                  key: redis-password
          envFrom:
          resources:
            limits: {}
            requests: {}
          livenessProbe:
            httpGet:
              path: /healthz
              port: 8082
            initialDelaySeconds: 10
            periodSeconds: 10
            timeoutSeconds: 1
            successThreshold: 1
            failureThreshold: 3
          readinessProbe:
            tcpSocket:
              port: 8082
            initialDelaySeconds: 10
            periodSeconds: 10
            timeoutSeconds: 1
            successThreshold: 1
            failureThreshold: 3
          volumeMounts:
            # Mounting into a path that will be read by Argo CD.
            # This secret will be autogenerated by Argo CD repo server unless it already exists. Users can create its own certificate to override it.
            # Ref: https://argoproj.github.io/argo-cd/operator-manual/tls/#inbound-tls-certificates-used-by-argocd-repo-sever
            - mountPath: /app/config/server/tls
              name: argocd-repo-server-tls
      volumes:
        - name: argocd-repo-server-tls
          secret:
            items:
              - key: tls.crt
                path: tls.crt
              - key: tls.key
                path: tls.key
              - key: ca.crt
                path: ca.crt
            optional: true
            secretName: argocd-repo-server-tls
---
# Source: root-chart/charts/argo-cd/templates/repo-server/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: release-name-argo-cd-repo-server
  namespace: "argo-cd"
  labels:
    app.kubernetes.io/name: argo-cd
    helm.sh/chart: argo-cd-4.0.2
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/component: repo-server
spec:
  replicas: 1
  strategy:
    type: RollingUpdate
  selector:
    matchLabels:
      app.kubernetes.io/name: argo-cd
      app.kubernetes.io/instance: release-name
      app.kubernetes.io/component: repo-server
  template:
    metadata:
      labels:
        app.kubernetes.io/name: argo-cd
        helm.sh/chart: argo-cd-4.0.2
        app.kubernetes.io/instance: release-name
        app.kubernetes.io/managed-by: Helm
        app.kubernetes.io/component: repo-server
    spec:
      serviceAccountName: release-name-argo-cd-argocd-repo-server

      affinity:
        podAffinity:

        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
            - podAffinityTerm:
                labelSelector:
                  matchLabels:
                    app.kubernetes.io/name: argo-cd
                    app.kubernetes.io/instance: release-name
                    app.kubernetes.io/component: repo-server
                namespaces:
                  - "argo-cd"
                topologyKey: kubernetes.io/hostname
              weight: 1
        nodeAffinity:

      securityContext:
        fsGroup: 1001
      initContainers:
        - name: wait-for-redis
          image: docker.io/bitnami/redis:7.0.4-debian-11-r2
          imagePullPolicy: "IfNotPresent"
          command:
            - /bin/bash
          args:
            - -ec
            - |
                #!/bin/bash

                set -o errexit
                set -o nounset
                set -o pipefail

                . /opt/bitnami/scripts/libos.sh
                . /opt/bitnami/scripts/liblog.sh

                check_redis_connection() {
                  local result="$(redis-cli -h release-name-redis-master -p 6379 PING)"
                  if [[ "$result" != "PONG" ]]; then
                    false
                  fi
                }

                info "Checking redis connection..."
                if ! retry_while "check_redis_connection"; then
                    error "Could not connect to the Redis server"
                    return 1
                else
                    info "Connected to the Redis instance"
                fi
          env:
            - name: REDISCLI_AUTH
              valueFrom:
                secretKeyRef:
                  name: release-name-redis
                  key: redis-password
      containers:
        - name: argocd-repo-server
          image: docker.io/bitnami/argo-cd:2.4.7-debian-11-r0
          imagePullPolicy: IfNotPresent
          securityContext:
            allowPrivilegeEscalation: false
            capabilities:
              drop:
              - all
            readOnlyRootFilesystem: false
            runAsNonRoot: true
            runAsUser: 1001
          args:
            - argocd-repo-server
            - --logformat
            - text
            - --loglevel
            - info
            - --redis
            - release-name-redis-master:6379
          ports:
            - name: repo-server
              containerPort: 8081
              protocol: TCP
          env:
            - name: REDIS_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: release-name-redis
                  key: redis-password
          envFrom:
          resources:
            limits: {}
            requests: {}
          livenessProbe:
            tcpSocket:
              port: 8081
            initialDelaySeconds: 10
            periodSeconds: 10
            timeoutSeconds: 1
            successThreshold: 1
            failureThreshold: 3
          readinessProbe:
            tcpSocket:
              port: 8081
            initialDelaySeconds: 10
            periodSeconds: 10
            timeoutSeconds: 1
            successThreshold: 1
            failureThreshold: 3
          volumeMounts:
            # Mounting into a path that will be read by Argo CD
            # Ref: https://argoproj.github.io/argo-cd/operator-manual/declarative-setup/#ssh-known-host-public-keys
            - name: ssh-known-hosts
              mountPath: /app/config/ssh
            # Mounting into a path that will be read by Argo CD.
            # This secret will be autogenerated by Argo CD repo server unless it already exists. Users can create its own certificate to override it.
            # Ref: https://argoproj.github.io/argo-cd/operator-manual/tls/#inbound-tls-certificates-used-by-argocd-repo-sever
            - mountPath: /app/config/server/tls
              name: argocd-repo-server-tls
            - mountPath: /app/config/gpg/keys
              name: gpg-keyring
            - mountPath: /tmp
              name: tmp-dir
      volumes:
        - name: ssh-known-hosts
          configMap:
            name: argocd-ssh-known-hosts-cm
        - name: argocd-repo-server-tls
          secret:
            items:
              - key: tls.crt
                path: tls.crt
              - key: tls.key
                path: tls.key
              - key: ca.crt
                path: ca.crt
            optional: true
            secretName: argocd-repo-server-tls
        - emptyDir: {}
          name: tmp-dir
        - emptyDir: {}
          name: gpg-keyring
---
# Source: root-chart/charts/argo-cd/templates/server/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: release-name-argo-cd-server
  namespace: "argo-cd"
  labels:
    app.kubernetes.io/name: argo-cd
    helm.sh/chart: argo-cd-4.0.2
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/component: server
spec:
  replicas: 1
  strategy:
    type: RollingUpdate
  selector:
    matchLabels:
      app.kubernetes.io/name: argo-cd
      app.kubernetes.io/instance: release-name
      app.kubernetes.io/component: server
  template:
    metadata:
      labels:
        app.kubernetes.io/name: argo-cd
        helm.sh/chart: argo-cd-4.0.2
        app.kubernetes.io/instance: release-name
        app.kubernetes.io/managed-by: Helm
        app.kubernetes.io/component: server
    spec:
      serviceAccountName: release-name-argo-cd-argocd-server

      affinity:
        podAffinity:

        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
            - podAffinityTerm:
                labelSelector:
                  matchLabels:
                    app.kubernetes.io/name: argo-cd
                    app.kubernetes.io/instance: release-name
                    app.kubernetes.io/component: server
                namespaces:
                  - "argo-cd"
                topologyKey: kubernetes.io/hostname
              weight: 1
        nodeAffinity:

      securityContext:
        fsGroup: 1001
      initContainers:
        - name: wait-for-redis
          image: docker.io/bitnami/redis:7.0.4-debian-11-r2
          imagePullPolicy: "IfNotPresent"
          command:
            - /bin/bash
          args:
            - -ec
            - |
                #!/bin/bash

                set -o errexit
                set -o nounset
                set -o pipefail

                . /opt/bitnami/scripts/libos.sh
                . /opt/bitnami/scripts/liblog.sh

                check_redis_connection() {
                  local result="$(redis-cli -h release-name-redis-master -p 6379 PING)"
                  if [[ "$result" != "PONG" ]]; then
                    false
                  fi
                }

                info "Checking redis connection..."
                if ! retry_while "check_redis_connection"; then
                    error "Could not connect to the Redis server"
                    return 1
                else
                    info "Connected to the Redis instance"
                fi
          env:
            - name: REDISCLI_AUTH
              valueFrom:
                secretKeyRef:
                  name: release-name-redis
                  key: redis-password
      containers:
        - name: argocd-server
          image: docker.io/bitnami/argo-cd:2.4.7-debian-11-r0
          imagePullPolicy: IfNotPresent
          securityContext:
            allowPrivilegeEscalation: false
            capabilities:
              drop:
              - all
            readOnlyRootFilesystem: false
            runAsNonRoot: true
            runAsUser: 1001
          args:
            - argocd-server
            - --staticassets
            - /opt/bitnami/argo-cd/app
            - --repo-server
            - release-name-argo-cd-repo-server:8081
            - --logformat
            - text
            - --loglevel
            - info
            # TODO(miguelaeh): Test the chart using redis sentinel enabled: https://github.com/argoproj/argo-cd/blob/2a410187565e15633b6f2a8c8d8da22cf02b257d/util/cache/cache.go#L40
            - --redis
            - release-name-redis-master:6379
          ports:
            - name: http
              containerPort: 8080
              protocol: TCP
          env:
            - name: REDIS_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: release-name-redis
                  key: redis-password
          envFrom:
          resources:
            limits: {}
            requests: {}
          livenessProbe:
            httpGet:
              path: /healthz
              port: 8080
            initialDelaySeconds: 10
            periodSeconds: 10
            timeoutSeconds: 1
            successThreshold: 1
            failureThreshold: 3
          readinessProbe:
            httpGet:
              path: /healthz
              port: 8080
            initialDelaySeconds: 10
            periodSeconds: 10
            timeoutSeconds: 1
            successThreshold: 1
            failureThreshold: 3
          volumeMounts:
            # Mounting into a path that will be read by Argo CD
            # Ref: https://argoproj.github.io/argo-cd/operator-manual/declarative-setup/#ssh-known-host-public-keys
            - name: ssh-known-hosts
              mountPath: /app/config/ssh
            # Mounting into a path that will be read by Argo CD.
            # This secret will be autogenerated by Argo CD repo server unless it already exists. Users can create its own certificate to override it.
            # Ref: https://argoproj.github.io/argo-cd/operator-manual/tls/#inbound-tls-certificates-used-by-argocd-repo-sever
            - mountPath: /app/config/server/tls
              name: argocd-repo-server-tls
      volumes:
        - name: ssh-known-hosts
          configMap:
            name: argocd-ssh-known-hosts-cm
        - name: argocd-repo-server-tls
          secret:
            items:
              - key: tls.crt
                path: tls.crt
              - key: tls.key
                path: tls.key
              - key: ca.crt
                path: ca.crt
            optional: true
            secretName: argocd-repo-server-tls
---
# Source: root-chart/charts/argo-cd/charts/redis/templates/master/application.yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: release-name-redis-master
  namespace: "argo-cd"
  labels:
    app.kubernetes.io/name: redis
    helm.sh/chart: redis-17.0.2
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/component: master
spec:
  replicas: 1
  selector:
    matchLabels:
      app.kubernetes.io/name: redis
      app.kubernetes.io/instance: release-name
      app.kubernetes.io/component: master
  serviceName: release-name-redis-headless
  updateStrategy:
    rollingUpdate: {}
    type: RollingUpdate
  template:
    metadata:
      labels:
        app.kubernetes.io/name: redis
        helm.sh/chart: redis-17.0.2
        app.kubernetes.io/instance: release-name
        app.kubernetes.io/managed-by: Helm
        app.kubernetes.io/component: master
      annotations:
        checksum/configmap: d9b985e436538016653e6a17410b558442e7faa7bfaca150b4661793e1c32120
        checksum/health: 3268fac447e0d3eeaafab895fb57f1371157f8aafb21156f603f6802a8370a54
        checksum/scripts: bcc5fb0b09b321dd6f1d05830ba7863044598b36f641a5271e75f52d1390b401
        checksum/secret: c6e11521e1bd32c590e111cb4ac715e0a1d7fea1e7adc40b90b3d5e77d043f26
    spec:

      securityContext:
        fsGroup: 1001
      serviceAccountName: release-name-redis
      affinity:
        podAffinity:

        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
            - podAffinityTerm:
                labelSelector:
                  matchLabels:
                    app.kubernetes.io/name: redis
                    app.kubernetes.io/instance: release-name
                    app.kubernetes.io/component: master
                namespaces:
                  - "argo-cd"
                topologyKey: kubernetes.io/hostname
              weight: 1
        nodeAffinity:

      terminationGracePeriodSeconds: 30
      containers:
        - name: redis
          image: docker.io/bitnami/redis:7.0.4-debian-11-r2
          imagePullPolicy: "IfNotPresent"
          securityContext:
            runAsUser: 1001
          command:
            - /bin/bash
          args:
            - -c
            - /opt/bitnami/scripts/start-scripts/start-master.sh
          env:
            - name: BITNAMI_DEBUG
              value: "false"
            - name: REDIS_REPLICATION_MODE
              value: master
            - name: ALLOW_EMPTY_PASSWORD
              value: "no"
            - name: REDIS_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: release-name-redis
                  key: redis-password
            - name: REDIS_TLS_ENABLED
              value: "no"
            - name: REDIS_PORT
              value: "6379"
          ports:
            - name: redis
              containerPort: 6379
          livenessProbe:
            initialDelaySeconds: 20
            periodSeconds: 5
            # One second longer than command timeout should prevent generation of zombie processes.
            timeoutSeconds: 6
            successThreshold: 1
            failureThreshold: 5
            exec:
              command:
                - sh
                - -c
                - /health/ping_liveness_local.sh 5
          readinessProbe:
            initialDelaySeconds: 20
            periodSeconds: 5
            timeoutSeconds: 2
            successThreshold: 1
            failureThreshold: 5
            exec:
              command:
                - sh
                - -c
                - /health/ping_readiness_local.sh 1
          resources:
            limits: {}
            requests: {}
          volumeMounts:
            - name: start-scripts
              mountPath: /opt/bitnami/scripts/start-scripts
            - name: health
              mountPath: /health
            - name: redis-data
              mountPath: /data
              subPath:
            - name: config
              mountPath: /opt/bitnami/redis/mounted-etc
            - name: redis-tmp-conf
              mountPath: /opt/bitnami/redis/etc/
            - name: tmp
              mountPath: /tmp
      volumes:
        - name: start-scripts
          configMap:
            name: release-name-redis-scripts
            defaultMode: 0755
        - name: health
          configMap:
            name: release-name-redis-health
            defaultMode: 0755
        - name: config
          configMap:
            name: release-name-redis-configuration
        - name: redis-tmp-conf
          emptyDir: {}
        - name: tmp
          emptyDir: {}
  volumeClaimTemplates:
    - metadata:
        name: redis-data
        labels:
          app.kubernetes.io/name: redis
          app.kubernetes.io/instance: release-name
          app.kubernetes.io/component: master
      spec:
        accessModes:
          - "ReadWriteOnce"
        resources:
          requests:
            storage: "8Gi"
---
# Source: root-chart/templates/argocd-apps/cert-manager/cert-manager.yaml
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: cert-manager
  namespace: argo-cd
  finalizers:
  - resources-finalizer.argocd.argoproj.io
spec:
  project: default
  source:
    chart: cert-manager
    repoURL: https://charts.jetstack.io
    targetRevision: 1.8.2
  destination:
    server: https://kubernetes.default.svc
    namespace: cert-manager
  syncPolicy:
    automated:
      prune: true
      selfHeal: true
---
# Source: root-chart/templates/argocd-apps/gitea.yaml
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: gitea
  namespace: argo-cd
  finalizers:
  - resources-finalizer.argocd.argoproj.io
spec:
  project: default
  source:
    chart: gitea
    repoURL: https://dl.gitea.io/charts/
    targetRevision: 5.0.9
    helm:
      values: |
        server:
          ingress:
            enabled: true
            hostname: gitea.eks-c01.ubn24.de
            annotations:
              kubernetes.io/ingress.class: nginx
              kubernetes.io/tls-acme: 'true'
              cert-manager.io/cluster-issuer: letsencrypt-staging
              nginx.ingress.kubernetes.io/backend-protocol: HTTPS
              nginx.ingress.kubernetes.io/force-ssl-redirect: 'true'
              nginx.ingress.kubernetes.io/ssl-passthrough: 'true'
            tls: true
  destination:
    server: https://kubernetes.default.svc
    namespace: gitea
  syncPolicy:
    automated:
      prune: true
      selfHeal: true
---
# Source: root-chart/templates/argocd-apps/kube-prometheus-stack.yaml
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: kube-prometheus-stack
  namespace: argo-cd
  finalizers:
  - resources-finalizer.argocd.argoproj.io
spec:
  project: default
  source:
    chart: kube-prometheus-stack
    repoURL: https://prometheus-community.github.io/helm-charts
    targetRevision: 37.0.0
    helm:
      values: |
        defaultRules:
          rules:
            etcd: false
            kubeScheduler: false
        kubeControllerManager:
          enabled: false
        kubeEtcd:
          enabled: false
        kubeScheduler:
          enabled: false
  destination:
    server: https://kubernetes.default.svc
    namespace: monitoring
  syncPolicy:
    automated:
      prune: true
      selfHeal: true
---
# Source: root-chart/templates/argocd-apps/root.yaml
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: root
  namespace: argo-cd
  finalizers:
  - resources-finalizer.argocd.argoproj.io
spec:
  project: default
  source:
    path: root-chart/
    repoURL: https://github.com/myhailo-rudenko/argocd-app-of-apps.git
    targetRevision: HEAD
  destination:
    server: https://kubernetes.default.svc
    namespace: argo-cd
  syncPolicy:
    automated:
      prune: true
      selfHeal: true
---
# Source: root-chart/templates/argocd-apps/cert-manager/cluster-issuers.yml
apiVersion: cert-manager.io/v1
kind: ClusterIssuer
metadata:
  name: letsencrypt-staging
  finalizers:
  - resources-finalizer.argocd.argoproj.io
spec:
  acme:
    server: https://acme-staging-v02.api.letsencrypt.org/directory
    email: admin@ubn24.de
    privateKeySecretRef:
      name: letsencrypt
    solvers:
    - http01:
        ingress:
          class: nginx
          podTemplate:
            spec:
              nodeSelector:
                "kubernetes.io/os": linux
---
# Source: root-chart/templates/argocd-apps/cert-manager/cluster-issuers.yml
apiVersion: cert-manager.io/v1
kind: ClusterIssuer
metadata:
  name: letsencrypt-prod
  finalizers:
  - resources-finalizer.argocd.argoproj.io
spec:
  acme:
    server: https://acme-v02.api.letsencrypt.org/directory
    email: admin@ubn24.de
    privateKeySecretRef:
      name: letsencrypt
    solvers:
    - http01:
        ingress:
          class: nginx
          podTemplate:
            spec:
              nodeSelector:
                "kubernetes.io/os": linux
